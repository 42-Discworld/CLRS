



<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-0.17.3, mkdocs-material-2.7.2">
    
    
      
        <title>23.2 The algorithms of Kruskal and Prim - CLRS Solutions</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.8d40d89b.css">
      
    
    
      <script src="../../assets/javascripts/modernizr.1aa3b519.js"></script>
    
    
      <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
      
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
    
      <link rel="stylesheet" href="../../css/extra.css">
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="github">
  <path fill="currentColor" d="M409.132,114.573c-19.608-33.596-46.205-60.194-79.798-79.8C295.736,15.166,259.057,5.365,219.271,5.365
		c-39.781,0-76.472,9.804-110.063,29.408c-33.596,19.605-60.192,46.204-79.8,79.8C9.803,148.168,0,184.854,0,224.63
		c0,47.78,13.94,90.745,41.827,128.906c27.884,38.164,63.906,64.572,108.063,79.227c5.14,0.954,8.945,0.283,11.419-1.996
		c2.475-2.282,3.711-5.14,3.711-8.562c0-0.571-0.049-5.708-0.144-15.417c-0.098-9.709-0.144-18.179-0.144-25.406l-6.567,1.136
		c-4.187,0.767-9.469,1.092-15.846,1c-6.374-0.089-12.991-0.757-19.842-1.999c-6.854-1.231-13.229-4.086-19.13-8.559
		c-5.898-4.473-10.085-10.328-12.56-17.556l-2.855-6.57c-1.903-4.374-4.899-9.233-8.992-14.559
		c-4.093-5.331-8.232-8.945-12.419-10.848l-1.999-1.431c-1.332-0.951-2.568-2.098-3.711-3.429c-1.142-1.331-1.997-2.663-2.568-3.997
		c-0.572-1.335-0.098-2.43,1.427-3.289c1.525-0.859,4.281-1.276,8.28-1.276l5.708,0.853c3.807,0.763,8.516,3.042,14.133,6.851
		c5.614,3.806,10.229,8.754,13.846,14.842c4.38,7.806,9.657,13.754,15.846,17.847c6.184,4.093,12.419,6.136,18.699,6.136
		c6.28,0,11.704-0.476,16.274-1.423c4.565-0.952,8.848-2.383,12.847-4.285c1.713-12.758,6.377-22.559,13.988-29.41
		c-10.848-1.14-20.601-2.857-29.264-5.14c-8.658-2.286-17.605-5.996-26.835-11.14c-9.235-5.137-16.896-11.516-22.985-19.126
		c-6.09-7.614-11.088-17.61-14.987-29.979c-3.901-12.374-5.852-26.648-5.852-42.826c0-23.035,7.52-42.637,22.557-58.817
		c-7.044-17.318-6.379-36.732,1.997-58.24c5.52-1.715,13.706-0.428,24.554,3.853c10.85,4.283,18.794,7.952,23.84,10.994
		c5.046,3.041,9.089,5.618,12.135,7.708c17.705-4.947,35.976-7.421,54.818-7.421s37.117,2.474,54.823,7.421l10.849-6.849
		c7.419-4.57,16.18-8.758,26.262-12.565c10.088-3.805,17.802-4.853,23.134-3.138c8.562,21.509,9.325,40.922,2.279,58.24
		c15.036,16.18,22.559,35.787,22.559,58.817c0,16.178-1.958,30.497-5.853,42.966c-3.9,12.471-8.941,22.457-15.125,29.979
		c-6.191,7.521-13.901,13.85-23.131,18.986c-9.232,5.14-18.182,8.85-26.84,11.136c-8.662,2.286-18.415,4.004-29.263,5.146
		c9.894,8.562,14.842,22.077,14.842,40.539v60.237c0,3.422,1.19,6.279,3.572,8.562c2.379,2.279,6.136,2.95,11.276,1.995
		c44.163-14.653,80.185-41.062,108.068-79.226c27.88-38.161,41.825-81.126,41.825-128.906
		C438.536,184.851,428.728,148.168,409.132,114.573z"/>
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="drawer"></label>
    
      <a href="#232-1" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../Chap22/22.1/" title="CLRS Solutions" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                CLRS Solutions
              </span>
              <span class="md-header-nav__topic">
                23.2 The algorithms of Kruskal and Prim
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  


  <a href="https://github.com/walkccc/CLRS/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      walkccc/CLRS
    </div>
  </a>

          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="drawer">
    <span class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </span>
    CLRS Solutions
  </label>
  
    <div class="md-nav__source">
      


  


  <a href="https://github.com/walkccc/CLRS/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      walkccc/CLRS
    </div>
  </a>

    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1" checked>
    
    <label class="md-nav__link" for="nav-1">
      VI Graph Algorithms
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        VI Graph Algorithms
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1-1" type="checkbox" id="nav-1-1">
    
    <label class="md-nav__link" for="nav-1-1">
      22 Elementary Graph Algorithms
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-1-1">
        22 Elementary Graph Algorithms
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap22/22.1/" title="22.1 Representations of graphs" class="md-nav__link">
      22.1 Representations of graphs
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap22/22.2/" title="22.2 Breadth-first search" class="md-nav__link">
      22.2 Breadth-first search
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap22/22.3/" title="22.3 Depth-first search" class="md-nav__link">
      22.3 Depth-first search
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap22/22.4/" title="22.4 Topological sort" class="md-nav__link">
      22.4 Topological sort
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap22/22.5/" title="22.5 Strongly connected components" class="md-nav__link">
      22.5 Strongly connected components
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1-1-6" type="checkbox" id="nav-1-1-6">
    
    <label class="md-nav__link" for="nav-1-1-6">
      Chap 22 Problems
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="3">
      <label class="md-nav__title" for="nav-1-1-6">
        Chap 22 Problems
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap22/Problems/22-1/" title="22-1 Classifying edges by breadth-first search" class="md-nav__link">
      22-1 Classifying edges by breadth-first search
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap22/Problems/22-2/" title="22-2 Articulation points, bridges, and biconnected components" class="md-nav__link">
      22-2 Articulation points, bridges, and biconnected components
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap22/Problems/22-3/" title="22-3 Euler tour" class="md-nav__link">
      22-3 Euler tour
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap22/Problems/22-4/" title="22-4 Reachability" class="md-nav__link">
      22-4 Reachability
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1-2" type="checkbox" id="nav-1-2" checked>
    
    <label class="md-nav__link" for="nav-1-2">
      23 Minimum Spanning Trees
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-1-2">
        23 Minimum Spanning Trees
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../23.1/" title="23.1 Growing a minimum spanning tree" class="md-nav__link">
      23.1 Growing a minimum spanning tree
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="toc">
        23.2 The algorithms of Kruskal and Prim
      </label>
    
    <a href="./" title="23.2 The algorithms of Kruskal and Prim" class="md-nav__link md-nav__link--active">
      23.2 The algorithms of Kruskal and Prim
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#232-1" title="23.2-1" class="md-nav__link">
    23.2-1
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-2" title="23.2-2" class="md-nav__link">
    23.2-2
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-3" title="23.2-3" class="md-nav__link">
    23.2-3
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-4" title="23.2-4" class="md-nav__link">
    23.2-4
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-5" title="23.2-5" class="md-nav__link">
    23.2-5
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-6-star" title="23.2-6 $\star$" class="md-nav__link">
    23.2-6 $\star$
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-7-star" title="23.2-7 $\star$" class="md-nav__link">
    23.2-7 $\star$
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-8" title="23.2-8" class="md-nav__link">
    23.2-8
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1-2-3" type="checkbox" id="nav-1-2-3">
    
    <label class="md-nav__link" for="nav-1-2-3">
      Chap 23 Problems
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="3">
      <label class="md-nav__title" for="nav-1-2-3">
        Chap 23 Problems
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Problems/23-1/" title="23-1 Second-best minimum spanning tree" class="md-nav__link">
      23-1 Second-best minimum spanning tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Problems/23-2/" title="23-2 Minimum spanning tree in sparse graphs" class="md-nav__link">
      23-2 Minimum spanning tree in sparse graphs
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Problems/23-3/" title="23-3 Bottleneck spanning tree" class="md-nav__link">
      23-3 Bottleneck spanning tree
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Problems/23-4/" title="23-4 Alternative minimum-spanning-tree algorithms" class="md-nav__link">
      23-4 Alternative minimum-spanning-tree algorithms
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1-3" type="checkbox" id="nav-1-3">
    
    <label class="md-nav__link" for="nav-1-3">
      24 Single-Source Shortest Paths
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-1-3">
        24 Single-Source Shortest Paths
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap24/24.1/" title="24.1 The Bellman-Ford algorithm" class="md-nav__link">
      24.1 The Bellman-Ford algorithm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap24/24.2/" title="24.2 Single-source shortest paths in directed acyclic graphs" class="md-nav__link">
      24.2 Single-source shortest paths in directed acyclic graphs
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap24/24.3/" title="24.3 Dijkstra's algorithm" class="md-nav__link">
      24.3 Dijkstra's algorithm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap24/24.4/" title="24.4 Difference constraints and shortest paths" class="md-nav__link">
      24.4 Difference constraints and shortest paths
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap24/24.5/" title="24.5 Proofs of shortest-paths properties" class="md-nav__link">
      24.5 Proofs of shortest-paths properties
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1-3-6" type="checkbox" id="nav-1-3-6">
    
    <label class="md-nav__link" for="nav-1-3-6">
      Chap 24 Problems
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="3">
      <label class="md-nav__title" for="nav-1-3-6">
        Chap 24 Problems
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap24/Problems/24-1/" title="24-1 Yen's improvement to Bellman-Ford" class="md-nav__link">
      24-1 Yen's improvement to Bellman-Ford
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap24/Problems/24-2/" title="24-2 Nesting boxes" class="md-nav__link">
      24-2 Nesting boxes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap24/Problems/24-3/" title="24-3 Arbitrage" class="md-nav__link">
      24-3 Arbitrage
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap24/Problems/24-4/" title="24-4 Gabow's scaling algorithm for single-source shortest paths" class="md-nav__link">
      24-4 Gabow's scaling algorithm for single-source shortest paths
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap24/Problems/24-5/" title="24-5 Karp's minimum mean-weight cycle algorithm" class="md-nav__link">
      24-5 Karp's minimum mean-weight cycle algorithm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap24/Problems/24-6/" title="24-6 Bitonic shortest paths" class="md-nav__link">
      24-6 Bitonic shortest paths
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1-4" type="checkbox" id="nav-1-4">
    
    <label class="md-nav__link" for="nav-1-4">
      25 All-Pairs Shortest Paths
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-1-4">
        25 All-Pairs Shortest Paths
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap25/25.1/" title="25.1 Shortest paths and matrix multiplication" class="md-nav__link">
      25.1 Shortest paths and matrix multiplication
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap25/25.2/" title="25.2 The Floyd-Warshall algorithm" class="md-nav__link">
      25.2 The Floyd-Warshall algorithm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap25/25.3/" title="25.3 Johnson's algorithm for sparse graphs" class="md-nav__link">
      25.3 Johnson's algorithm for sparse graphs
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1-4-4" type="checkbox" id="nav-1-4-4">
    
    <label class="md-nav__link" for="nav-1-4-4">
      Chap 25 Problems
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="3">
      <label class="md-nav__title" for="nav-1-4-4">
        Chap 25 Problems
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap25/Problems/25-1/" title="25-1 Transitive closure of a dynamic graph" class="md-nav__link">
      25-1 Transitive closure of a dynamic graph
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap25/Problems/25-2/" title="25-2 Shortest paths in epsilon-dense graphs" class="md-nav__link">
      25-2 Shortest paths in epsilon-dense graphs
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1-5" type="checkbox" id="nav-1-5">
    
    <label class="md-nav__link" for="nav-1-5">
      26 Maximum Flow
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-1-5">
        26 Maximum Flow
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap26/26.1/" title="26.1 Flow networks" class="md-nav__link">
      26.1 Flow networks
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap26/26.2/" title="26.2 The Ford-Fulkerson method" class="md-nav__link">
      26.2 The Ford-Fulkerson method
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap26/26.3/" title="26.3 Maximum bipartite matching" class="md-nav__link">
      26.3 Maximum bipartite matching
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap26/26.4/" title="26.4 Push-relabel algorithms" class="md-nav__link">
      26.4 Push-relabel algorithms
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap26/26.5/" title="26.5 The relabel-to-front algorithm" class="md-nav__link">
      26.5 The relabel-to-front algorithm
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1-5-6" type="checkbox" id="nav-1-5-6">
    
    <label class="md-nav__link" for="nav-1-5-6">
      Chap 26 Problems
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="3">
      <label class="md-nav__title" for="nav-1-5-6">
        Chap 26 Problems
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap26/Problems/26-1/" title="26-1 Escape problem" class="md-nav__link">
      26-1 Escape problem
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap26/Problems/26-2/" title="26-2 Minimum path cover" class="md-nav__link">
      26-2 Minimum path cover
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap26/Problems/26-3/" title="26-3 Algorithmic consulting" class="md-nav__link">
      26-3 Algorithmic consulting
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap26/Problems/26-4/" title="26-4 Updating maximum flow" class="md-nav__link">
      26-4 Updating maximum flow
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap26/Problems/26-5/" title="26-5 Maximum flow by scaling" class="md-nav__link">
      26-5 Maximum flow by scaling
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../Chap26/Problems/26-6/" title="26-6 The Hopcroft-Karp bipartite matching algorithm" class="md-nav__link">
      26-6 The Hopcroft-Karp bipartite matching algorithm
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#232-1" title="23.2-1" class="md-nav__link">
    23.2-1
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-2" title="23.2-2" class="md-nav__link">
    23.2-2
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-3" title="23.2-3" class="md-nav__link">
    23.2-3
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-4" title="23.2-4" class="md-nav__link">
    23.2-4
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-5" title="23.2-5" class="md-nav__link">
    23.2-5
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-6-star" title="23.2-6 $\star$" class="md-nav__link">
    23.2-6 $\star$
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-7-star" title="23.2-7 $\star$" class="md-nav__link">
    23.2-7 $\star$
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#232-8" title="23.2-8" class="md-nav__link">
    23.2-8
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/walkccc/CLRS/edit/master/docs/Chap23/23.2.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                  <h1>23.2 The algorithms of Kruskal and Prim</h1>
                
                <h2 id="232-1">23.2-1</h2>
<blockquote>
<p>Kruskal's algorithm can return different spanning trees for the same input graph $G$, depending on how it breaks ties when the edges are sorted into order. Show that for each minimum spanning tree $T$ of $G$, there is a way to sort the edges of $G$ in Kruskal's algorithm so that the algorithm returns $T$.</p>
</blockquote>
<p>Suppose that we wanted to pick $T$ as our minimum spanning tree. Then, to obtain this tree with Kruskal's algorithm, we will order the edges first by their weight, but then will resolve ties in edge weights by picking an edge first if it is contained in the minimum spanning tree, and treating all the edges that aren't in $T$ as being slightly larger, even though they have the same actual weight.</p>
<p>With this ordering, we will still be finding a tree of the same weight as all the minimum spanning trees $w(T)$. However, since we prioritize the edges in $T$, we have that we will pick them over any other edges that may be in other minimum spanning trees.</p>
<h2 id="232-2">23.2-2</h2>
<blockquote>
<p>Suppose that we represent the graph $G = (V, E)$ as an adjacency matrix. Give a simple implementation of Prim's algorithm for this case that runs in $O(V^2)$ time.</p>
</blockquote>
<p>At each step of the algorithm we will add an edge from a vertex in the tree created so far to a vertex not in the tree, such that this edge has minimum weight. Thus, it will be useful to know, for each vertex not in the tree, the edge from that vertex to some vertex in the tree of minimal weight. We will store this information in an array $A$, where $A[u] = (v, w)$ if $w$ is the weight of $(u, v)$ and is minimal among the weights of edges from $u$ to some vertex $v$ in the tree built so far. We'll use $A[u].1$ to access $v$ and $A[u].2$ to access $w$.</p>
<div class="highlight"><pre><span></span><span class="n">PRIM</span><span class="o">-</span><span class="n">ADJ</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">initialize</span> <span class="n">A</span> <span class="n">with</span> <span class="n">every</span> <span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">NIL</span><span class="p">,</span> <span class="err">∞</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">V</span>
        <span class="k">if</span> <span class="n">Adj</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">u</span> <span class="n">in</span> <span class="n">V</span> <span class="o">-</span> <span class="n">T</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="mf">.2</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">T</span> <span class="err">∪</span> <span class="p">{</span><span class="n">k</span><span class="p">}</span>
        <span class="n">k</span><span class="p">.</span><span class="n">PI</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="mf">.1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">V</span>
            <span class="k">if</span> <span class="n">Adf</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="n">and</span> <span class="n">Adj</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="mf">.2</span>
                <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Adj</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
</pre></div>

<h2 id="232-3">23.2-3</h2>
<blockquote>
<p>For a sparse graph $G = (V, E)$, where $|E| = \Theta(V)$, is the implementation of Prim's algorithm with a Fibonacci heap asymptotically faster than the binary-heap implementation? What about for a dense graph, where $|E| = \Theta(V^2)$? How must the sizes $|E|$ and $|V|$ be related for the Fibonacci-heap implementation to be asymptotically faster than the binary-heap implementation?</p>
</blockquote>
<p>Prim's algorithm implemented with a Binary heap has runtime $O((V + E)\lg V)$, which in the sparse case, is just $O(V\lg V)$. The implementation with Fibonacci heaps is</p>
<p>$$O(E + V\lg V) = O(V + V\lg V) = O(V \lg V).$$</p>
<ul>
<li>In the sparse case, the two algorithms have the same asymptotic runtimes.</li>
<li>
<p>In the dense case.</p>
<ul>
<li>
<p>The binary heap implementation has a runtime of </p>
<p>$$O((V + E)\lg V) = O((V + V^2)\lg V) = O(V^2\lg V).$$</p>
</li>
<li>
<p>The Fibonacci heap implementation has a runtime of</p>
<p>$$O(E + V\lg V) = O(V^2 + V\lg V) = O(V^2).$$</p>
</li>
</ul>
<p>So, in the dense case, we have that the Fibonacci heap implementation is asymptotically faster.</p>
</li>
<li>
<p>The Fibonacci heap implementation will be asymptotically faster so long as $E = \omega(V)$. Suppose that we have some function that grows more quickly than linear, say $f$, and $E = f(V)$. </p>
</li>
<li>The binary heap implementation will have runtime of</li>
</ul>
<p>$$O((V + E)\lg V) = O((V + f(V))\lg V) = O(f(V)\lg V).$$</p>
<p>However, we have that the runtime of the Fibonacci heap implementation will have runtime of</p>
<p>$$O(E + V\lg V) = O(f(V) + V\lg V).$$</p>
<p>This runtime is either $O(f(V))$ or $O(V\lg V)$ depending on if $f(V)$ grows more or less quickly than $V\lg V$ respectively.</p>
<p>In either case, we have that the runtime is faster than $O(f(V)\lg V)$.</p>
<h2 id="232-4">23.2-4</h2>
<blockquote>
<p>Suppose that all edge weights in a graph are integers in the range from $1$ to $|V|$. How fast can you make Kruskal's algorithm run? What if the edge weights are integers in the range from $1$ to $W$ for some constant $W$?</p>
</blockquote>
<p>We know that Kruskal's algorithm takes $O(V)$ time for initialization, $O(E\lg E)$ time to sort the edges, and $O(E\alpha(V))$ time for the disjoint-set operations, for a total running time of $O(V + E\lg E + E\alpha(V)) = O(E\lg E)$.</p>
<p>If we knew that all of the edge weights in the graph were integers in the range from $1$ to $|V|$, then we could sort the edges in $O(V + E)$ time using counting sort. Since the graph is connected, $V = O(E)$, and so the sorting time is reduced to $O(E)$. This would yield a total running time of $O(V + E + E\alpha(V)) = O(E\alpha(V))$, again since $V = O(E)$, and since $E = O(E\alpha(V))$. The time to process the edges, not the time to sort them, is now the dominant term. Knowledge about the weights won't help speed up any other part of the algorithm, since nothing besides the sort uses the weight values.</p>
<p>If the edge weights were integers in the range from $1$ to $W$ for some constant $W$, then we could again use counting sort to sort the edges more quickly. This time, sorting would take $O(E + W) = O(E)$ time, since $W$ is a constant. As in the first part, we get a total running time of $O(E\alpha(V))$.</p>
<h2 id="232-5">23.2-5</h2>
<blockquote>
<p>Suppose that all edge weights in a graph are integers in the range from $1$ to $|V|$. How fast can you make Prim's algorithm run? What if the edge weights are integers in the range from $1$ to $W$ for some constant $W$?</p>
</blockquote>
<p>The time taken by Prim's algorithm is determined by the speed of the queue operations. With the queue implemented as a Fibonacci heap, it takes $O(E + V\lg V)$ time.</p>
<p>Since the keys in the priority queue are edge weights, it might be possible to implement the queue even more efficiently when there are restrictions on the possible edge weights.</p>
<p>We can improve the running time of Prim's algorithm if $W$ is a constant by implementing the queue as an array $Q[0..W + 1]$ (using the $W + 1$ slot for $\text{key} = \infty$), where each slot holds a doubly linked list of vertices with that weight as their key. Then $\text{EXTRACT-MIN}$ takes only $O(W) = O(1)$ time (just scan for the first nonempty slot), and $\text{DECREASE-KEY}$ takes only $O(1)$ time (just remove the vertex from the list it's in and insert it at the front of the list indexed by the new key). This gives a total running time of $O(E)$, which is the best possible asymptotic time (since $\Omega(E)$ edges must be processed).</p>
<p>However, if the range of edge weights is $1$ to $|V|$, then $\text{EXTRACT-MIN}$ takes $\Theta(V)$ time with this data structure. So the total time spent doing $\text{EXTRACT-MIN}$ is $\Theta(V^2)$, slowing the algorithm to $\Theta(E + V^2) = \Theta(V^2)$. In this case, it is better to keep the Fibonacci-heap priority queue, which gave the $\Theta(E + V\lg V)$ time.</p>
<p>Other data structures yield better running times:</p>
<ul>
<li>van Emde Boas trees (see Chapter 20) give an upper bound of $O(E + V\lg\lg V)$ time for Prim's algorithm.</li>
<li>A redistributive heap (used in the single-source shortest-paths algorithm of Ahuja, Mehlhorn, Orlin, and Tarjan, and mentioned in the chapter notes for Chapter 24) gives an upper bound of $O(E + V \sqrt{\lg V})$ for Prim's algorithm.</li>
</ul>
<h2 id="232-6-star">23.2-6 $\star$</h2>
<blockquote>
<p>Suppose that the edge weights in a graph are uniformly distributed over the halfopen interval $[0, 1)$. Which algorithm, Kruskal's or Prim's, can you make run faster?</p>
</blockquote>
<p>For input drawn from a uniform distribution I would use bucket sort with Kruskal's algorithm, for expected linear time sorting of edges by weight. This would achieve expected runtime $O(E\alpha(V))$.</p>
<h2 id="232-7-star">23.2-7 $\star$</h2>
<blockquote>
<p>Suppose that a graph $G$ has a minimum spanning tree already computed. How quickly can we update the minimum spanning tree if we add a new vertex and incident edges to $G$?</p>
</blockquote>
<p>We start with the following lemma.</p>
<p><strong><em>Lemma</em></strong></p>
<p>Let $T$ be a minimum spanning tree of $G = (V, E)$, and consider a graph $G' = (V', E')$ for which $G$ is a subgraph, i.e., $V \subseteq V'$ and $E \subseteq E'$. Let $\overline T = E - T$ be the edges of $G$ that are not in $T$. Then there is a minimum spanning tree of $G'$ that includes no edges in $\overline T$.</p>
<p><strong><em>Proof</em></strong> </p>
<p>By Exercise 23.2-1, there is a way to order the edges of $E$ so that Kruskal's algorithm, when run on $G$, produces the minimum spanning tree $T$. We will show that Kruskal's algorithm, run on $G'$, produces a minimum spanning tree $T'$ that includes no edges in $\overline T$. We assume that the edges in $E$ are considered in the same relative order when Kruskal's algorithm is run on $G$ and on $G'$. We first state and prove the following claim.</p>
<p><strong><em>Claim</em></strong> </p>
<p>For any pair of vertices $u, v \in V$, if these vertices are in the same set after Kruskal's algorithm run on $G$ considers any edge $(x, y) \in E$, then they are in the same set after Kruskal's algorithm run on $G'$ considers $(x, y)$.</p>
<p><strong><em>Proof of claim</em></strong> </p>
<p>Let us order the edges of $E$ by nondecreasing weight as $\langle (x_1, y_1), (x_2, y_2), \ldots, (x_k, y_k) \rangle$, where $k = |E|$. This sequence gives the order in which the edges of $E$ are considered by Kruskal's algorithm, whether it is run on $G$ or on $G'$. We will use induction, with the inductive hypothesis that if $u$ and $v$ are in the same set after Kruskal's algorithm run on $G$ considers an edge $(x_i, y_i)$, then they are in the same set after Kruskal's algorithm run on $G'$ considers the same edge. We use induction on $i$.</p>
<p><strong>Basis:</strong> For the basis, $i = 0$. Kruskal's algorithm run on $G$ has not considered any edges, and so all vertices are in different sets. The inductive hypothesis holds trivially.</p>
<p><strong>Inductive step:</strong> We assume that any vertices that are in the same set after Kruskal's algorithm run on $G$ has considered edges $\langle (x_1, y_1), (x_2, y_2), \ldots, (x_{i - 1}, y_{i - 1}) \rangle$ are in the same set after Kruskal's algorithm run on $G'$ has considered the same edges. When Kruskal's algorithm runs on $G'$, after it considers $(x_{i - 1}, y_{i - 1})$, it may consider some edges in $E' - E$ before considering $(x_i, y_i)$. The edges in $E' - E$ may cause $\text{UNION}$ operations to occur, but sets are never divided. Hence, any vertices that are in the same set after Kruskal's algorithm run on $G'$ considers $(x_{i - 1}, y_{i - 1})$ are still in the same set when $(x_i, y_i)$ is considered.</p>
<p>When Kruskal's algorithm run on $G$ considers $(x_i, y_i)$, either $x_i$ and $y_i$ are found to be in the same set or they are not.</p>
<ul>
<li>If Kruskal's algorithm run on $G$ finds $x_i$ and $y_i$ to be in the same set, then no $\text{UNION}$ operation occurs. The sets of vertices remain the same, and so the inductive hypothesis continues to hold after considering $(x_i, y_i)$.</li>
<li>If Kruskal's algorithm run on $G$ finds $x_i$ and $y_i$ to be in different sets, then the operation $\text{UNION}(x_i, y_i)$ will occur. Kruskal's algorithm run on $G'$ will find that either $x_i$ and $y_i$ are in the same set or they are not. By the inductive hypothesis, when edge $(x_i, y_i)$ is considered, all vertices in $x_i$'s set when Kruskal's algorithm runs on $G$ are in $x_i$'s set when Kruskal's algorithm runs on $G'$, and the same holds for $y_i$. Regardless of whether Kruskal's algorithm run on $G'$ finds $x_i$ and $y_i$ to already be in the same set, their sets are united after considering $(x_i, y_i)$, and so the inductive hypothesis continues to hold after considering $(x_i, y_i)$. (#claim)</li>
</ul>
<p>With the claim in hand, we suppose that some edge $(u, v) \in \overline T$ is placed into $T'$. That means that Kruskal's algorithm run on $G$ found $u$ and $v$ to be in the same set (since $(u, v) \in \overline T$ ) but Kruskal's algorithm run on $G'$ found $u$ and $v$ to be in different sets (since $(u, v)$ is placed into $T'$). This fact contradicts the claim, and we conclude that no edge in $\overline T$ is placed into $T'$. Thus, by running Kruskal's algorithm on $G$ and $G'$, we demonstrate that there exists a minimum spanning tree of $G'$ that includes no edges in $\overline T$. (#lemma)</p>
<p>We use this lemma as follows. Let $G' = (V', E')$ be the graph $G = (V, E)$ with the one new vertex and its incident edges added. Suppose that we have a minimum spanning tree $T$ for $G$. We compute a minimum spanning tree for $G'$ by creating the graph $G'' = (V', E'')$, where $E''$ consists of the edges of $T$ and the edges in $E' - E$ (i.e., the edges added to $G$ that made $G'$), and then finding a minimum spanning tree $T'$ for $G''$. By the lemma, there is a minimum spanning tree for $G'$ that includes no edges of $E - T$. In other words, $G'$ has a minimum spanning tree that includes only edges in $T$ and $E' - E$ ; these edges comprise exactly the set $E''$. Thus, the the minimum spanning tree $T'$ of $G''$ is also a minimum spanning tree of $G'$.</p>
<p>Even though the proof of the lemma uses Kruskal's algorithm, we are not required to use this algorithm to find $T'$. We can find a minimum spanning tree by any means we choose. Let us use Prim's algorithm with a Fibonacci-heap priority queue. Since $|V'| = |V| + 1$ and $|E''| \le 2|V| - 1$ ($E''$ contains the $|V| - 1$ edges of $T$ and at most $|V|$ edges in $E' - E$ ), it takes $O(V)$ time to construct $G''$, and the run of Prim's algorithm with a Fibonacci-heap priority queue takes time $O(E'' + V'\lg V) = O(V\lg V)$. Thus, if we are given a minimum spanning tree of $G$, we can compute a minimum spanning tree of $G'$ in $O(V\lg V)$ time.</p>
<h2 id="232-8">23.2-8</h2>
<blockquote>
<p>Professor Borden proposes a new divide-and-conquer algorithm for computing minimum spanning trees, which goes as follows. Given a graph $G = (V, E)$, partition the set $V$ of vertices into two sets $V_1$ and $V_2$ such that $|V_1|$ and $|V_2|$ differ by at most $1$. Let $E_1$ be the set of edges that are incident only on vertices in $V_1$, and let $E_2$ be the set of edges that are incident only on vertices in $V_2$. Recursively solve a minimum-spanning-tree problem on each of the two subgraphs $G_1 = (V_1, E_1)$ and $G_2 = (V_2, E_2)$. Finally, select the minimum-weight edge in $E$ that crosses the cut $(V_1, V_2)$, and use this edge to unite the resulting two minimum spanning trees into a single spanning tree.</p>
<p>Either argue that the algorithm correctly computes a minimum spanning tree of $G$, or provide an example for which the algorithm fails.</p>
</blockquote>
<p>The algorithm fails. Suppose $E = \{(u, v), (u, w), (v, w)\}$, the weight of $(u, v)$ and $(u, w)$ is $1$, and the weight of $(v, w)$ is $1000$, partition the set into two sets $V_1 = \{u\}$ and $V_2 = \{v, w\}$.</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../23.1/" title="23.1 Growing a minimum spanning tree" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                23.1 Growing a minimum spanning tree
              </span>
            </div>
          </a>
        
        
          <a href="../Problems/23-1/" title="23-1 Second-best minimum spanning tree" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                23-1 Second-best minimum spanning tree
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Built by
        <a href="http://walkccc.github.io/">Jay Chen</a>
      </div>
      
        
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.b438e6c5.js"></script>
      
      <script>app.initialize({version:"0.17.3",url:{base:"../.."}})</script>
      
        <script src="../../javascripts/extra.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
    
      
    
  </body>
</html>